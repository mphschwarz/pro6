/*
 * WB_Gneiss_Sample_Code_LLD.c
 *
 *  Created on: 2017/7/19
 *      Author: YAChen1
 */




/**
  ******************************************************************************
  * @file    /WB_Gneiss_Sample_Code_LLD.c
  * @author  Winbond FAE Steam Lin
  * @version V1.2.0
  * @date    20-June-2016
  * @brief   This code provide the low level RPMC hardware operate function based on STM32F205.
  *
  * COPYRIGHT 2015 Winbond Electronics Corporation.
*/

#include "WB_Gneiss_Sample_Code_LLD.h"
/* public array use for RPMC algorithm */
unsigned char message[16];	// Message data use for insturction input
unsigned char counter[4];	// counter data (32bit)
unsigned char tag[12];		// Tag data use for increase counter
unsigned char signature[32];	// Signature data use for every instruction output


/********************
Function: Read counter
Argument:
return:	counter number
date: 2015/8/12
*********************/
unsigned int WB_RPMC_ReadCounterData(){
  return (((((counter[0]*0x100)+counter[1])*0x100)+counter[2])*0x100)+counter[3];
}

/********************
Function: RPMC read RPMC status
Argument: checkall

	checkall = 0: only read out RPMC status
	checkall = 1: Read out counter data, tag, signature information

return: RPMC status
date: 2015/8/12
*********************/
unsigned int WB_RPMC_ReadRPMCstatus(unsigned int checkall){
  unsigned int i;
  unsigned char RPMCstatus;
  unsigned char Send_Buff[2] = {0x00,0x00};
  unsigned char Get_Buff[49] = {0};

  memset(Send_Buff, 0XFF, sizeof(Send_Buff));
  memset(Get_Buff, 0xFF, sizeof(Get_Buff));

  Send_Buff[0]=0x96;	// read RPMC status command
  if(checkall ==0)  {
	alt_avalon_spi_command(SPI_0_BASE, 0, 2, Send_Buff, 1, Get_Buff, 0);
	RPMCstatus = Get_Buff[0];
  }
  else{							// After signature matched reqeust counter instruction, counter data can readout as follow.
    alt_avalon_spi_command(SPI_0_BASE, 0, 2, Send_Buff, 49, Get_Buff, 0);  //50 - 49?
    RPMCstatus = Get_Buff[0];
    printf("Readstatus tag:\n");
	for(i=0;i<12;i++){			// Update 2016/06/20 Update "i < 32 > i < 12"
    tag[i]=Get_Buff[i+1];			// tag information repeat
    printf("%d ",tag[i]);
    }
	printf("\nReadStatus Counter Data:\n");
    for(i=0;i<4;i++){
    counter[i] = Get_Buff[i+12+1];	// counter data readout   Get_Buff[i+12+1];
    printf("%d ",counter[i]);
    }

    printf("\nReadStatus Signature:\n");
    for(i=0;i<32;i++){
    signature[i]=Get_Buff[i+16+1];	// signature repeat
    printf("%d ",signature[i]);
    }
    printf("\n");
  }//end else
  return RPMCstatus;
}

/********************
Function: RPMC request counter data
Argument:
	cadr: selected Counter address, from 1~4
	hmackey: 32 byte HMACKEY which is generated by WB_RPMC_UpHMACkey()
	input_tag: 12 byte input Tag data, which can be time stamp, serial number or random number.
	these data would repeat after success WB_RPMC_ReqCounter() operation
return:
date: 2015/8/12
*********************/
void WB_RPMC_ReqCounter(unsigned int cadr, unsigned char *hmackey,unsigned char *input_tag){
  unsigned int i;
  unsigned char Send_Buff[48] = {0};
  unsigned char Get_Buff[1] = {0xFF};
  memset(Send_Buff, 0XFF, sizeof(Send_Buff));

  message[0]=0x9B;
  message[1]=0x03;
  message[2]=cadr-1;
  message[3]=0x00;
  for(i=0;i<12;i++){	// Target datasheet issue
    message[i+4]=*(input_tag+i);
  }

  hmacsha256(hmackey,32,message,16,signature);  // caculate signature by SHA256


  for(i=0;i<16;i++){
    Send_Buff[i]=message[i];
  }
  printf("Reqcounter signature:\r\n");
  for(i=0;i<32;i++){
    Send_Buff[i+16]=signature[i];
    printf("%d ",signature[i]);
  }
  printf("\n");
  alt_avalon_spi_command(SPI_0_BASE, 0, 48, Send_Buff, 0, Get_Buff, 0);
  return;
}

/********************
Function: RPMC write rootkey
Argument:
	cadr: selected Counter address, from 1~4
	rootkey: 32 byte rootkey infomration.
return: RPMC status
date: 2015/8/12
*********************/
unsigned int WB_RPMC_WrRootKey(unsigned int cadr,unsigned char *rootkey){
  unsigned int i;
  unsigned char Send_Buff[64] = {0};
  unsigned char Get_Buff[1] = {0xFF};
  memset(Send_Buff, 0XFF, sizeof(Send_Buff));

  memset(message, 0x00, sizeof(message[0])*8);
  message[0]=0x9B;
  message[1]=0x00;
  message[2]=cadr-1;// counter address 0~3,so -1
  message[3]=0x00;

  hmacsha256(rootkey,32,message,4,signature);	// caculate signature by SHA256


  Send_Buff[0] = message[0];
  Send_Buff[1] = message[1];
  Send_Buff[2] = message[2];
  Send_Buff[3] = message[3];
  for(i=0;i<32;i++){
    Send_Buff[i+4] = *(rootkey+i);
  }
  for(i=0;i<28;i++){
    Send_Buff[i+36] = signature[i+4];
  }

  alt_avalon_spi_command(SPI_0_BASE, 0, 64, Send_Buff, 0, Get_Buff, 0);
  while(WB_RPMC_ReadRPMCstatus(0)&0x01==0x01){
	// wait until RPMC operation done
  }
  return WB_RPMC_ReadRPMCstatus(0);
}

/********************
Function: RPMC Update HMAC key, this function should call in every Gneiss power on
Argument:
	cadr: selected Counter address, from 1~4
	rootkey: rootkey use for generate HMAC key
	hmac4: 4 byte input hmac message data, which can be time stamp, serial number or random number.
	hmackey: 32 byte HMACKEY, which would be use for increase/request counter after WB_RPMC_UpHMACkey() operation success
return:
date: 2015/8/12
*********************/
unsigned int WB_RPMC_UpHMACkey(unsigned int cadr,unsigned char *rootkey,unsigned char *hmac4,unsigned char *hmackey){
  unsigned int i;
  unsigned char Send_Buff[40] = {0};
  unsigned char Get_Buff[1] = {0xFF};
  memset(Send_Buff, 0XFF, sizeof(Send_Buff));

  message[0]=0x9B;
  message[1]=0x01;
  message[2]=cadr - 1;
  message[3]=0x00;
  message[4]=*(hmac4+0);
  message[5]=*(hmac4+1);
  message[6]=*(hmac4+2);
  message[7]=*(hmac4+3);

  hmacsha256(rootkey,32,hmac4,4,hmackey);	// use rootkey generate HMAC key by SHA256
  hmacsha256(hmackey,32,message,8,signature);	// caculate signature by SHA256

  for(i=0;i<8;i++){
     Send_Buff[i] = message[i];
  }
  for(i=0;i<32;i++){
     Send_Buff[i+8] = signature[i];
  }

  alt_avalon_spi_command(SPI_0_BASE, 0, 40, Send_Buff, 0, Get_Buff, 0);
  while(WB_RPMC_ReadRPMCstatus(0)&0x01==0x01){
	// wait until RPMC operation done
  }
  return WB_RPMC_ReadRPMCstatus(0);
}

/********************
Function: RPMC request counter data
Argument:
	cadr: selected Counter address, from 1~4
	hmackey: 32 byte HMACKEY which is generated by WB_RPMC_UpHMACkey()
	input_tag: 12 byte input Tag data, which can be time stamp, serial number or random number.
	these data would repeat after success WB_RPMC_ReqCounter() operation
return:
date: 2015/8/12
*********************/
unsigned int WB_RPMC_IncCounter(unsigned int cadr,unsigned char *hmackey,unsigned char *input_tag){
  unsigned int i;
  unsigned char Send_Buff[40] = {0};
  unsigned char Get_Buff[1] = {0xFF};
  memset(Send_Buff, 0XFF, sizeof(Send_Buff));

  WB_RPMC_ReqCounter(cadr, hmackey, input_tag);
  WB_RPMC_ReadRPMCstatus(1);	// Get counter information

  message[0]=0x9B;
  message[1]=0x02;
  message[2]=cadr-1;
  message[3]=0x00;
  for(i=0;i<4;i++){
     message[i+4]=counter[i];  //counter[i];
  }
  hmacsha256(hmackey,32,message,8,signature);	// caculate signature by SHA256

  for(i=0;i<8;i++){
     Send_Buff[i] = message[i]; //message[i+i];
  }
  for(i=0;i<32;i++){
     Send_Buff[i+8] = signature[i]; //signature[i];
  }
  alt_avalon_spi_command(SPI_0_BASE, 0, 40, Send_Buff, 0, Get_Buff, 0);
  while(WB_RPMC_ReadRPMCstatus(0)&0x01==0x01){
	// wait until RPMC operation done
  }
  return WB_RPMC_ReadRPMCstatus(0);
}

/********************
Function: RPMC Challenge signature. Main security operation
Argument:
	cadr: selected Counter address, from 1~4
	hmackey: 32 byte HMACKEY which is generated by WB_RPMC_UpHMACkey()
	input_tag: 12 byte input Tag data, which can be time stamp, serial number or random number.
return:
	Challlenge result. if signature match, return 0.
date: 2015/12/09
*********************/
unsigned char WB_RPMC_Challenge(unsigned int cadr, unsigned char *hmackey,unsigned char *input_tag){
	unsigned char Verify_signature[32];	// signature for verification. should match signature[32]
	unsigned int i;
	WB_RPMC_ReqCounter(cadr, hmackey, input_tag);
	WB_RPMC_ReadRPMCstatus(1);	// Get counter information. In this stage, tag[12], counter[4], signature[32] is updated.
	// Comment: the message using for signature is tag[0:11]+count[0:3] data, you can also use memcpy to casecade these data
	/*
	memcpy(message, tag, 12);
	memcpy(message+12, counter, 4);
	*/
	for(i = 0; i < 12; i++){
		message[i] = tag[i];	// message [0:11] = tag[0:11]
	}
	for(i = 0; i < 4; i++){
		message[12+i] = counter[i];	// message [12:15] = counter[0:3]  //count[i];
	}
	hmacsha256(hmackey,32,message,16,Verify_signature);	// Verification signature should as same as security output
	printf("Verify_signature:\r\n");
	for(i = 0; i < 32; i++){
		printf("%d ",Verify_signature[i]);
	}
	printf("\n");
	return memcmp(Verify_signature, signature, 32);		// Compare Verification signature (computed by controllor) and internal signature (return from security Flash by request counter operation)
}

/************************ (C) COPYRIGHT Winbond Electronics Corporation *****END OF FILE****/
